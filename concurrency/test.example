// out1 := make(chan string)
// out2 := make(chan string)
// // go process("order", out1)

// go func() {
// 	for {
// 		time.Sleep(time.Second / 2)
// 		out1 <- "order processed"
// 	}
// }()
// go func() {
// 	for {
// 		time.Sleep(time.Second)
// 		out2 <- "refund processed"
// 	}
// }()
// for {
// 	select {
// 	case msg := <-out1:
// 		// fmt.Println(<-out1)
// 		fmt.Println(msg)
// 	case msg := <-out2:
// 		fmt.Println(msg)
// 	}
// }

// for msg := range out1 {
// 	// msg := <-out1
// 	fmt.Println(msg)
// }

// go process("refunds") // when this exits the main is done
// fmt.Scanln()


#######
// func process(item string, out chan string) {
// 	defer close(out)
// 	for i := 1; true; i++ {
// 		time.Sleep(time.Second / 2)
// 		out <- item // putting data into channel
// 		// fmt.Println("Processed", i, item)
// 	}
// }

// Never close a channel on receiving end, as sending end will panic
// One go routine should have access to the shared resource of the console at a time
// Use a Mutex to syn access to shared resource
